import { defineConfig, IndexHtmlTransformContext, Plugin, UserConfig } from 'vite';
import path from 'path';
import fs from 'fs/promises';
import typescriptPlugin from '@rollup/plugin-typescript';
import { Input, InputAction, InputType, Packer } from 'roadroller';
import CleanCSS from 'clean-css';
import { statSync } from 'fs';
const { execFileSync } = require('child_process');
import ect from 'ect-bin';

const htmlMinify = require('html-minifier'),
      tmp = require('tmp'),
      ClosureCompiler = require('google-closure-compiler').compiler;

export default defineConfig(({ command }) => {
   const config: UserConfig = {
      server: {
         port: 3000,
      },
      resolve: {
         alias: {
            '@': path.resolve(__dirname, './src'),
         }
      },
      plugins: undefined
   };

   if (command === 'build') {
      config.esbuild = false;
      config.base = '';
      config.build = {
         minify: false,
         target: 'es2020',
         modulePreload: { polyfill: false },
         assetsInlineLimit: 800,
         assetsDir: '',
         rollupOptions: {
            output: {
               inlineDynamicImports: true,
               manualChunks: undefined,
               assetFileNames: `[name].[ext]`,
            },

         },
         outDir: '.build',
      };
      config.plugins = [
         typescriptPlugin({ outDir: config.build.outDir }),
         closurePlugin(),
         roadrollerPlugin(),
         ectPlugin(),
      ];
   }

   return config;
});

function closurePlugin(): Plugin {
   return {
      name: 'closure-compiler',
      renderChunk: applyClosure,
      enforce: 'post',
   };
}

async function applyClosure(js: string): Promise<{ code: string }> {
   const tmpobj = tmp.fileSync();

   // TODO: Would it save anything to replace consts with lets?
   // js = js.replace(/const /g, 'let ');

   await fs.writeFile(tmpobj.name, js);

   const closureCompiler = new ClosureCompiler({
      js: tmpobj.name,
      externs: 'externs.js',
      compilation_level: 'ADVANCED',
      language_in: 'ECMASCRIPT_2020',
      language_out: 'ECMASCRIPT_2020',
   });

   return new Promise((resolve, reject) => {
      closureCompiler.run((_exitCode: string, stdOut: string, stdErr: string) => {
         if (stdOut !== '') {
            resolve({ code: stdOut });
         } else if (stdErr !== '') { // only reject if stdout isn't generated
            reject(stdErr);
            return;
         }

         console.warn(stdErr); // If we make it here, there were warnings but no errors
      });
   });
}


function roadrollerPlugin(): Plugin {
   return {
      name: 'vite:roadroller',
      transformIndexHtml: {
         enforce: 'post',
         transform: async (html: string, ctx?: IndexHtmlTransformContext): Promise<void> => {
            // Only use this plugin during build
            if (!ctx || !ctx.bundle) {
               return;
            }

            const options = {
               includeAutoGeneratedTags: true,
               removeAttributeQuotes: true,
               removeComments: true,
               removeRedundantAttributes: true,
               removeScriptTypeAttributes: true,
               removeStyleLinkTypeAttributes: true,
               sortClassName: true,
               useShortDoctype: true,
               collapseWhitespace: true,
               collapseInlineTagWhitespace: true,
               removeEmptyAttributes: true,
               removeOptionalTags: true,
               sortAttributes: true,
               minifyCSS: true,
            };

            const bundleOutputs = Object.values(ctx.bundle),
                  jsFile = bundleOutputs.find((output) => { return output.fileName.endsWith('.js'); }) as any,
                  cssFile = bundleOutputs.find((output) => output.fileName.endsWith('.css')) as any,
                  htmlWithEmbeddedCSS = cssFile ? embedCSS(html, cssFile) : html,
                  minifiedHtml = await htmlMinify.minify(htmlWithEmbeddedCSS, options);

            await fs.rm(`${__dirname}/.minified`, { recursive: true });
            await fs.mkdir(`${__dirname}/.minified`, { recursive: true });
            await fs.writeFile(`${__dirname}/.minified/index.html`, await embedJS(minifiedHtml, jsFile));
         },
      },
   };
}

/**
 * Transforms the given JavaScript code into a packed version.
 * @param html The original HTML.
 * @param chunk The JavaScript output chunk from Rollup/Vite.
 * @returns The transformed HTML with the JavaScript embedded.
 */
async function embedJS(html: string, chunk: { fileName: string; code: string; }): Promise<string> {
   const scriptTagRemoved = html.replace(new RegExp(`<script[^>]*?src=[\./]*${chunk.fileName}[^>]*?></script>`), ''),
         htmlInJS = `document.write('${scriptTagRemoved}');` + chunk.code.trim();

   const inputs: Input[] = [
      {
         data: htmlInJS,
         type: 'js' as InputType,
         action: 'eval' as InputAction,
      },
   ];

   let options;
   if (process.env.USE_RR_CONFIG) {
      try {
         options = JSON.parse(await fs.readFile(`${__dirname}/roadroller-config.json`, 'utf-8'));
      } catch(error) {
         throw new Error('Roadroller config not found. Generate one or use the regular build option');
      }
   } else {
      options = { allowFreeVars: true };
   }

   const packer = new Packer(inputs, options);

   await packer.optimize(process.env.USE_RR_CONFIG ? 0 : 2);

   const { firstLine, secondLine } = packer.makeDecoder();

   return `<script>\n${firstLine}\n${secondLine}\n</script>`;
}

/**
 * Embeds CSS into the HTML.
 * @param html The original HTML.
 * @param asset The CSS asset.
 * @returns The transformed HTML with the CSS embedded.
 */
function embedCSS(html: string, asset: { fileName: string; source: string; }): string {
   const reCSS = new RegExp(`<link rel="stylesheet"[^>]*?href="[\./]*${asset.fileName}"[^>]*?>`),
         cleanCSS = new CleanCSS({ level: 2 }) as any,
         code = `<style>${cleanCSS.minify(asset.source as string).styles}</style>`;

   return html.replace(reCSS, code);
}

/**
 * Creates the ECT plugin that uses Efficient-Compression-Tool to build a zip file.
 * @returns The ECT plugin.
 */
function ectPlugin(): Plugin {
   return {
      name: 'vite:ect',
      writeBundle: async (): Promise<void> => {
         try {
            const assetFiles = (await fs.readdir(`${__dirname}/public/`)).map((filename) => { return `${__dirname}/public/${filename}`; }),
                  args = ['-strip', '-zip', '-10009', `${__dirname}/.minified/index.html`, ...assetFiles],
                  result = execFileSync(ect, args),
                  stats = statSync(`${__dirname}/.minified/index.zip`);

            console.log(args);

            console.log('ECT result', result.toString().trim());
            console.log('ZIP size', stats.size);
         } catch (err) {
            console.log('ECT error', err);
         }
      },
   };
}
